<#
#
#>

Param(
   [Parameter(Position=0)]
   [ValidateSet('install','uninstall','start','stop','restart','ping','console','attach','list','usage')]
   [System.String]$Command="usage"
)

Set-Variable erts_vsn -option Constant -value "<%= erts_vsn %>"

function Set-Bindir
{
  param([string] $releaseRoot)
  $parentOfReleaseRoot = Split-Path $releaseRoot -Parent
  $baseBinDir = Split-Path $parentOfReleaseRoot -Parent
  "$baseBinDir\erts-$erts_vsn\bin"
}

Set-Variable binaryNotFound -option Constant -value "No binary found"
Set-Variable rel_name -option Constant -value "<%= release_name %>"
Set-Variable rel_vsn -option Constant -value "<%= release_version %>"
Set-Variable erl_opts  -option Constant -value "<%= erl_opts %>"
$bindir = Set-Bindir $PSScriptRoot
Set-Variable werl -option Constant -value "$bindir\werl.exe"

#Start here on 2/7/2017
#set boot_script variable
function Set-BootScriptVar
{
  if Test-Path "%rel_dir%\%rel_name%.boot" (
  set boot_script=%rel_dir%\
) else (
  set boot_script=%rel_dir%\start
)

function Fix-PathsWithLongNamesOrSpaces
{
    param([string] $pathToFix)
    $pathParts = $pathToFix.Split([System.IO.Path]::DirectorySeparatorChar)
    #for each element in array if it contains a space, surround it with double quotes
    #test for two things:
    # Does the directory contain spaces 
    # Is any portion of the directory longer than 8 characters

    #If either of these is true, we need to wrap the path with double quotes
}

function Set-ReleaseRoot
{
    $script_dir = $PSScriptRoot
    $script_dir
}


function Find-ErtsDir
{
    $release_root = Set-ReleaseRoot
    $possible_erts_dir = "$release_root\erts-$erts_vsn"
    Write-Host "$possible_erts_dir"

}

function Test-ServiceIsInstalled
{
    param([string]$servicename)
    try
    {
	$svc = Get-Service -Name $servicename -ErrorAction SilentlyContinue
	$svc -ne $null
    }
    catch{$false}
}

function Get-BinaryInPath
{
    param([string]$binaryname)

    $bin = Get-Command $binaryname -ErrorAction SilentlyContinue

    if($bin -ne $null)
    {
	$bin.Definition
    }
    else
    {
	$bin
    }
}

function Get-BinaryInProgramFiles
{
    param([string]$binaryname)
    cd $env:ProgramFiles

    # Can only use Get-ChildItem if binary is in Path.
    $bin = Get-ChildItem $binaryname -ErrorAction SilentlyContinue -Recurse 
    if ($bin -ne $null)
    {
	$bin.Definition
    }
    else
    {
        $bin
    }
}

function Get-BinaryByName
{
    param([string]$binaryname)

    $binInPath = Get-BinaryInPath($binaryname)

    if ($binInPath -eq $null)
    {
	$binInProgramFiles = Get-BinaryInProgramFiles($binaryname)
	if ($binInProgramFiles -eq $null)
	{
	    $binaryNotFound
	}
        else
	{
	    $binInProgramFiles
	}
    }
    else
    {
	$binInPath
    }
}

#Start a console
function Execute-Console
{
  Invoke-Item "$rel_name console" $werl -boot "$boot_script" $sys_config  -args_file "$vm_args"
}


function Display-Usage
{
    $scriptName = Split-Path -Path $MyInvocation.ScriptName -Leaf
    Write-Host "usage: $scriptName (install|uninstall|start|stop|restart|upgrade|downgrade|console|ping|list|attach)"
    exit
}

switch ($Command)
{
  "usage"
  {
    Display-Usage;
    break
  }
  "console"
  {
    Write-Host "Hit the console branch"
    break;
  }
}
